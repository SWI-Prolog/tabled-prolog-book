\contentsline {chapter}{\numberline {1}Background and Motivation}{1}
\contentsline {chapter}{\numberline {2}Introduction to Prolog}{6}
\contentsline {section}{\numberline {2.1}Prolog as a Procedural Programming Language}{6}
\contentsline {subsection}{\numberline {2.1.1}Assign-once Variables}{7}
\contentsline {subsection}{\numberline {2.1.2}Nondeterminism}{11}
\contentsline {subsubsection}{Prolog execution as the execution of multiple machines}{12}
\contentsline {subsection}{\numberline {2.1.3}Executing Programs in XSB}{13}
\contentsline {subsection}{\numberline {2.1.4}The Scheduling of Machine Execution in Prolog}{18}
\contentsline {section}{\numberline {2.2}Grammars in Prolog}{21}
\contentsline {section}{\numberline {2.3}Prolog as a Database Query Langauge}{26}
\contentsline {section}{\numberline {2.4}Deductive Databases}{27}
\contentsline {section}{\numberline {2.5}Summary}{30}
\contentsline {section}{\numberline {2.6}Exercises}{30}
\contentsline {section}{\numberline {2.7}Exercise Discussion}{32}
\contentsline {chapter}{\numberline {3}Introduction to First-Order Logic}{34}
\contentsline {section}{\numberline {3.1}Propositional Logic}{36}
\contentsline {subsection}{\numberline {3.1.1}Syntax}{36}
\contentsline {subsection}{\numberline {3.1.2}Semantics}{36}
\contentsline {subsection}{\numberline {3.1.3}Deduction}{38}
\contentsline {subsubsection}{Soundness}{39}
\contentsline {subsubsection}{Completeness}{40}
\contentsline {subsection}{\numberline {3.1.4}Horn Clauses}{41}
\contentsline {subsubsection}{Horn Clauses, Unit Resolution}{43}
\contentsline {section}{\numberline {3.2}First Order Logic (FOL)}{44}
\contentsline {subsection}{\numberline {3.2.1}Syntax}{44}
\contentsline {subsection}{\numberline {3.2.2}Semantics}{46}
\contentsline {subsection}{\numberline {3.2.3}Deduction}{49}
\contentsline {subsubsection}{Resolution in FOL}{51}
\contentsline {subsubsection}{Horn Clauses, SLD}{54}
\contentsline {subsubsection}{Prolog as FO Horn Clauses}{54}
\contentsline {subsubsection}{Limitations of Prolog/SLD and what can be done}{54}
\contentsline {section}{\numberline {3.3}Exercises}{58}
\contentsline {chapter}{\numberline {4}Tabling and Datalog Programming}{63}
\contentsline {subsubsection}{XSB tabled execution as the execution of concurrent machines}{64}
\contentsline {section}{\numberline {4.1}More on Transitive Closure}{68}
\contentsline {section}{\numberline {4.2}Other Datalog Examples}{72}
\contentsline {section}{\numberline {4.3}Some Simple Graph Problems}{73}
\contentsline {subsection}{\numberline {4.3.1}Stongly Connected Components in a DAG}{73}
\contentsline {subsection}{\numberline {4.3.2}Connected Components in an Undirected Graph}{74}
\contentsline {section}{\numberline {4.4}Genome Examples}{75}
\contentsline {section}{\numberline {4.5}Subsumptive Tabling}{75}
\contentsline {section}{\numberline {4.6}Inferring When to Table}{75}
\contentsline {subsubsection}{On the Complexity of Tabled Datalog Programs}{78}
\contentsline {section}{\numberline {4.7}Datalog Optimization in XSB}{80}
\contentsline {section}{\numberline {4.8}Exercises}{80}
\contentsline {chapter}{\numberline {5}Grammars}{83}
\contentsline {section}{\numberline {5.1}An Expression Grammar}{83}
\contentsline {section}{\numberline {5.2}Representing the Input String as Facts}{85}
\contentsline {section}{\numberline {5.3}Mixing Tabled and Prolog Evaluation}{87}
\contentsline {section}{\numberline {5.4}So What Kind of Parser is it?}{88}
\contentsline {section}{\numberline {5.5}Building Parse Trees}{89}
\contentsline {section}{\numberline {5.6}Computing First Sets of Grammars}{92}
\contentsline {section}{\numberline {5.7}Linear Parsing of LL(k) and LR(k) Grammars}{94}
\contentsline {section}{\numberline {5.8}Parsing of Context Sensitive Grammars}{98}
\contentsline {section}{\numberline {5.9}Substring Matching}{102}
\contentsline {section}{\numberline {5.10}Exercises}{105}
\contentsline {chapter}{\numberline {6}Automata Theory in XSB}{108}
\contentsline {section}{\numberline {6.1}Finite State Machines}{108}
\contentsline {subsection}{\numberline {6.1.1}Intersection of FSM's}{111}
\contentsline {subsection}{\numberline {6.1.2}Epsilon-free FSM's}{112}
\contentsline {subsection}{\numberline {6.1.3}Deterministic FSM's}{114}
\contentsline {subsection}{\numberline {6.1.4}Complements of FSM's}{116}
\contentsline {subsection}{\numberline {6.1.5}Minimization of FSM's}{119}
\contentsline {subsection}{\numberline {6.1.6}Regular Expressions}{123}
\contentsline {section}{\numberline {6.2}Grammars Revisited}{126}
\contentsline {section}{\numberline {6.3}Push-Down Automata}{128}
\contentsline {section}{\numberline {6.4}Exercises}{128}
\contentsline {chapter}{\numberline {7}Dynamic Programming in XSB}{130}
\contentsline {section}{\numberline {7.1}The Knap-Sack Problem}{130}
\contentsline {section}{\numberline {7.2}Sequence Comparisons}{132}
\contentsline {section}{\numberline {7.3}??}{133}
\contentsline {section}{\numberline {7.4}Exercises}{133}
\contentsline {chapter}{\numberline {8}HiLog Programming}{134}
\contentsline {section}{\numberline {8.1}Generic Programs}{134}
\contentsline {section}{\numberline {8.2}Object Centered Programming in XSB with HiLog}{138}
\contentsline {chapter}{\numberline {9}Debugging Tabled Programs}{139}
\contentsline {chapter}{\numberline {10}Aggregation}{141}
\contentsline {section}{\numberline {10.1}Tabled Agggregation and Lattice Operations: Min, Max}{142}
\contentsline {section}{\numberline {10.2}Tabled Agggregation and the Fold Operation: sum}{143}
\contentsline {section}{\numberline {10.3}Long Path Example}{148}
\contentsline {section}{\numberline {10.4}Recursive Aggregation}{150}
\contentsline {subsection}{\numberline {10.4.1}Shortest Path}{150}
\contentsline {subsection}{\numberline {10.4.2}Reasoning with Uncertainty: Annotated Logic}{151}
\contentsline {subsection}{\numberline {10.4.3}Longest Path}{152}
\contentsline {subsection}{\numberline {10.4.4}Markov Decision Processes}{152}
\contentsline {section}{\numberline {10.5}Scheduling Issues}{154}
\contentsline {section}{\numberline {10.6}Stratified Aggregation}{154}
\contentsline {chapter}{\numberline {11}Incremental Table Maintenance}{155}
\contentsline {chapter}{\numberline {12}Negation in XSB}{156}
\contentsline {section}{\numberline {12.1}Completion Semantics}{160}
\contentsline {section}{\numberline {12.2}Negation through Fixed Points}{163}
\contentsline {section}{\numberline {12.3}General Negation}{169}
\contentsline {subsection}{\numberline {12.3.1}Clark's Completion Semantics}{170}
\contentsline {subsection}{\numberline {12.3.2}Stable Model Semantics}{172}
\contentsline {subsection}{\numberline {12.3.3}Well-Founded Semantics}{174}
\contentsline {section}{\numberline {12.4}Other Stuff to think about?}{179}
\contentsline {section}{\numberline {12.5}Approximate Reasoning}{179}
\contentsline {section}{\numberline {12.6}Representation of Partial Knowledge with Well-Founded Models}{180}
\contentsline {chapter}{\numberline {13}Meta-Programming}{185}
\contentsline {section}{\numberline {13.1}Meta-Interpreters in XSB}{185}
\contentsline {subsection}{\numberline {13.1.1}A Metainterpreter for Disjunctive Logic Programs}{185}
\contentsline {subsection}{\numberline {13.1.2}A Metainterpreter for Explicit Negation}{185}
\contentsline {section}{\numberline {13.2}Abstract Interpretation}{185}
\contentsline {subsection}{\numberline {13.2.1}AI of a Simple Nested Procedural Language}{186}
\contentsline {chapter}{\numberline {14}XSB Modules}{191}
\contentsline {chapter}{\numberline {15}Handling Large Fact Files}{192}
\contentsline {section}{\numberline {15.1}Indexing}{192}
\contentsline {section}{\numberline {15.2}Compiling Fact Files}{195}
\contentsline {section}{\numberline {15.3}Dynamically Loaded Fact Files}{196}
\contentsline {section}{\numberline {15.4}Indexing Static Program Clauses}{197}
\contentsline {chapter}{\numberline {16}Table Builtins}{199}
\contentsline {chapter}{\numberline {17}XSB System Facilities}{200}
